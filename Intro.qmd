---
title: "Julia para Ciência de Dados"
subtitle: "Um guia introdutório para importar, transformar, analisar e modelar dados"
lang: "pt"
author: "**Professor: Carlos Trucíos (DE)** <br> **Instrutores:** Arthur da Silva (DMA), Henrique Velloso (DE) e Sarah Pereira (DMA)."
institute: "7ª  Semana da Matemática Aplicada (SEMAP), <br> Universidade Estadual de Campinas (UNICAMP) <br> Agosto de 2025"
knitr:
    opts_chunk: 
      fig.align: 'center'
execute:
    message: false
    warning: false
format:
    revealjs:
        slide-number: true
        toc: true
        toc-depth: 1
        toc-title: Agenda
        self-contained: true
        chalkboard: false
        width: 1600
        height: 900
        theme: [default, styles.scss]
        incremental: true
        code-fold: false
        logo: "imagens/imecc.png"
        footer: "7ª SEMAP    |   Agosto de 2025    |    [www.ime.unicamp.br/julialang](https://ime.unicamp.br/julialang)"
        highlight-style: "a11y"
        title-slide-attributes:
            data-background-image: "imagens/unicamp.png"
            data-background-size: 20%
            data-background-position: 99% 5%
            data-background-opacity: "1"
editor: source
---


```{r}
library(JuliaCall)
julia_setup()
```



# Por que Julia?

## Por que escolher Julia?

-   A linguagem de programação `Julia`, lançada oficialmente em 2012, tem se destacado como uma alternativa moderna para ciência de dados e computação científica, competindo com linguagens como `Matlab`, `Python` e `R`;
-   É utilizada não apenas na academia, [mas também fora dela](https://ime.unicamp.br/julialang/Blog/Julia%20no%20Mercado%20de%20Trabalho.html);
-   `Julia` é gratuita;
-   `Julia` oferece desempenho próximo ao de C++, aliado à facilidade de aprendizado e sintaxe simples, comparáveis a `Python` e `R`;
-   `Julia` permite escrever código com símbolos matemáticos diretamente `r emo::ji("nerd")`, facilitando a expressão de conceitos científicos;
-   `Julia` resolve o problema das duas linguagens `r emo::ji("cool")`;
-   Porque o projeto [Do Zero ao Julia](www.ime.unicamp.br/julialang) é 100\% Unicamper (`r emo::ji("dance")`);
-   Etc.

## Do Zero ao Julia

<center>
![Website do projeto"Do Zero ao Julia": www.ime.unicamp.br/julialang](imagens/DoZeroaoJulia.png){width=70%}
</center>





# Primeiros passos
## Primeiros passos


<center>
::: {#fig-colab layout-ncol=2}

![Passo 1: Abrir o Colab https://colab.research.google.com/](imagens/colab.png){width=40%}

![Passo 2: Criar novo notebook](imagens/colab_novo_notebook.png){width=60%}

Google Colaboratory (Colab)
:::

</center>




## Primeiros passos

<center>
::: {#fig-colab layout-ncol=2}

![Passo 3: Configurar o Colab](imagens/colab_01.png){width=50%}

![Passo 4: Julia pronto pra ação](imagens/colab_02.png)

Julia no Colab
:::
</center>


## Primeiros passos

Atribuindo valores a diferentes variáveis e vetores

```{julia}
#| echo: true
x = 20;
y = 8.3;
nome = "Julia";
idade = 19;
nomes  = ["Julia", "Lucas", "Pedro", "Carlos", "Maria", "Luisa", "Marcelo", "Camila"];
idades = [19, 20, 18, 22, 21, 19, 17, 23];
peso   = [65.5, 70.5, 65.2, 70.1, 65.1, 65.4, 65.3, 65.2];
```



## Primeiros passos


Acessando aos elementos dos vetores


```{julia}
#| echo: true
idades[2]
nomes[3]
```


## Primeiros passos

Qual a diferença entre

```{julia}
#| eval: false
#| echo: true
log(idades)
```

e

```{julia}
#| eval: false
#| echo: true
log.(idades)
```


. . . 

Qual código está correto?

```{julia}
#| eval: false
#| echo: true
idades + 1    
idades .+ 1  
```


. . . 


> **Observação:** O . (dot) faz com que a operação seja feita em todos os elementos do vetor.




## Primeiros passos

```{julia}
#| echo: true
#| eval: false
# Matrizes
A = [1.0 2.0 3.0; 4.0 5.0 6.0]   # 2x3 de Float64
B = [1 2 3; 4 5 6]  # 2x3 de Int
Z = zeros(3, 4) # Matriz de zeros
O = ones(Int, 2, 5) # Matriz de uns
R = rand(3, 3)   # Aleatória uniforme [0,1)
N = randn(3, 3)  # Aleatória normal padrão
```


. . . 

Como acessar aos elementos da matriz?

```{julia}
#| echo: true
#| eval: false
A[1, 2]         # elemento da 1ª linha, 2ª coluna
A[2, :]         # linha 2 inteira
A[:, 3]         # coluna 3 inteira
A[1:2, 2:3]     # submatriz
A[1, 2] = 10.0  # alterar valor
```


## Primeiros passos

Instalar pacotes:

```{julia}
#| echo: true
#| eval: false
using Pkg
Pkg.add("Statistics")
Pkg.add("Random")
```


. . . 

Carregar pacotes:

```{julia}
#| echo: true
using LinearAlgebra
using Statistics
using Random
```

. . . 


::: {.callout-note icon=false}
Boas práticas em `Julia` são:

1. Carregar os pacotes logo no começo do script
2. Carregar cada pacote um a um (linha a linha)
3. Carregar os pacotes em ordem alfabetica.

Se quiser saber mais acerca de boas práticas, veja [aqui](https://github.com/JuliaDiff/BlueStyle).
:::



# Importação de dados

## Importação de dados

Nesta seção veremos como importar nossos _datasets_, estando eles armazenados localmente ou online. Também veremos a diferença na leitura de diferentes formatos, como **.csv**, **.txt** e **.xlsx**.

. . . 


`Julia` conta com diversos pacotes para leitura de _datasets_, dentre eles:

``` julia
import Pkg

Pkg.add("DataFrames");
Pkg.add("CSV")
Pkg.add("XLSX")
```

. . . 

- `DataFrames` : Manipulação e análise de dados em formato tabular, similar ao pandas (`Python`) ou data.frame (`R`);
- `CSV` : Leitura e escrita de arquivos CSV de forma rápida e eficiente;
- `XLSX` : Leitura e escrita de arquivos Excel (.xlsx).

## Funções básicas

Com os pacotes necessários instalados, agora vejamos como as funções de leitura funcionam:

``` julia
using DataFrames, CSV, XLSX

# .csv
df_csv = CSV.read("caminho/dados.csv", DataFrame)

# .txt
df_txt = CSV.read("caminho/dados.txt", DataFrame, delim=';')

# .xlsx
sheets = XLSX.readxlsx("caminho/dados.xlsx")
df_xlsx = DataFrame(sheets)
```

## Funções básicas

Podemos usar a função `download()` para baixar um arquivo temporariamente e retorna o caminho local onde ele foi salvo.

**Ex.:**

``` julia
dados_csv = CSV.read(download(url), DataFrame, delim=';')

first(dados_csv, 5) # Podemos usar a função first() para visualizar as primeiras linhas do dataset
```

## Leitura da base de dados

Agora, vamos ler os dados que usaremos na aula de hoje.

```{julia}
#| echo: false
begin
    import Pkg
    redirect_stdout(devnull) do
        redirect_stderr(devnull) do
            Pkg.add("TidierData")
            Pkg.add("PrettyTables")
        end
    end
end
```

```{julia}
#| echo: fenced

begin
    import Pkg
    redirect_stdout(devnull) do
        redirect_stderr(devnull) do
            Pkg.add("DataFrames")
            Pkg.add("CSV")
            Pkg.add("XLSX")
        end
    end
end
```

```{julia}
#| echo: true

using CSV
using DataFrames

file = "https://raw.githubusercontent.com/Arthur-Dionizio/minicurso-julia/main/datasets/dataset.csv";
dados = CSV.read(download(file), DataFrame);
first(dados, 5)
```

## Leitura da base de dados

```{julia}
#| echo: true

using DataFrames
using TidierData

@chain dados begin
    @slice(1:6)
end
```


## Leitura da base de dados

::: {.callout-note icon=false}
### Conhecendo o dataset

1. **track_name**: Nome da faixa;
2. **artists**: Os nomes dos artistas que interpretaram a faixa. Se houver mais de um artista, eles serão separados por ';' ;
3. **album_name**: O nome do álbum de onde a faixa pertence;
4. **popularity**: A popularidade de uma faixa é um valor entre 0 e 100, sendo 100 o mais popular, sendo calculada a partir (de forma geral) do número de streams daquela faixa, e o quão recente foram essas streams;
5. **duration_ms**: A duração da faixa em milissegundos;
6. **danceability**: A dançabilidade descreve o quão adequada uma faixa é para dançar com base em uma combinação de elementos musicais, incluindo andamento, estabilidade do ritmo, força da batida e regularidade geral. Um valor de 0,0 é o menos dançante e 1,0 o mais dançante;
:::



## Leitura da base de dados

::: {.callout-note icon=false}
### Conhecendo o dataset

7. **energy**: Energia é uma medida de 0,0 a 1,0 e representa uma medida perceptual de intensidade e atividade. Normalmente, músicas energéticas parecem rápidas, altas e barulhentas. Por exemplo, o death metal tem alta energia, enquanto um prelúdio de Bach tem baixa pontuação na escala;
8. **loudness**: O volume total de uma faixa em decibéis (dB);
9. **speechiness**: Detecta a presença de palavras faladas em uma faixa. Quanto mais exclusivamente semelhante à fala for a gravação (por exemplo, talk show, audiolivro, poesia), mais próximo de 1,0 será o valor do atributo. Valores acima de 0,66 descrevem faixas que provavelmente são compostas inteiramente de palavras faladas. Valores entre 0,33 e 0,66 descrevem faixas que podem conter música e fala, seja em seções ou em camadas, incluindo casos como rap. Valores abaixo de 0,33 provavelmente representam música e outras faixas que não se assemelham à fala.
10. **acousticness**: Uma medida de confiança de 0,0 a 1,0 para determinar se a faixa é acústica. 1,0 representa alta confiança de que a faixa é acústica.
:::




## Leitura da base de dados

::: {.callout-note icon=false}
### Conhecendo o dataset
11. **valence**: Uma medida de 0,0 a 1,0 que descreve a positividade musical transmitida por uma faixa. Faixas com alta valência soam mais positivas (por exemplo, felizes, alegres, eufóricas), enquanto faixas com baixa valência soam mais negativas (por exemplo, tristes, deprimidas, raivosas);
12. **tempo**: O andamento estimado geral de uma faixa em batidas por minuto (BPM);
13. **track_genre**: O gênero da faixa;
14. **instrumentalness**: Prevê se uma faixa não contém vocais. Sons de "Ooh" e "aah" são tratados como instrumentais neste contexto. Faixas de rap ou palavra falada são claramente "vocais". Quanto mais próximo o valor de instrumentalidade estiver de 1,0, maior a probabilidade de a faixa não conter conteúdo vocal.
15. **liveness**: Detecta a presença de público na gravação. Valores mais altos de ao vivo representam uma probabilidade maior de que a faixa tenha sido tocada ao vivo. Um valor acima de 0,8 fornece alta probabilidade de que a faixa seja ao vivo.
:::



# Manipulação de banco de dados

## Tidier.jl

A biblioteca `Tidier.jl` possui vários pacotes que auxiliam na manipulação e análise de datasets. Para quem está vindo do `R`, esses pacotes são bem similares e intuitivos. Aqui estão alguns dos pacotes:

- `TidierData` : Implementação 100% `Julia` dos pacotes `dplyr` e `tidyr` do `R`. Usado na tranformação e manipulação dos dados;
- `TidierPlots` : Implementação 100% `Julia` do pacote `ggplot2` do `R`;
- `TidierStrings` : O objetivo deste pacote é replicar o `stringr` do `R` em `Julia` de uma forma que funcione com o Tidier ou como uma função autônoma.

. . . 

> Acessem o link `https://tidierorg.github.io/Tidier.jl/v1.6.1/` para mais informações!

## Pacote TidierData.jl

Para a nossa análise de hoje, vamos utilizar principalmente o pacote `TidierData`.

. . . 


::: {.callout-note icon=false}
### Funções Macro

Para suportar a programação no estilo `R`, o `TidierData.jl` é implementado usando **macros**. Isso ocorre porque as **macros** são capazes de "capturar" o código antes de executá-lo, o que permite que o pacote suporte "expressões *tidy*" semelhantes ao `R` que, de outra forma, não seriam consideradas código `Julia` válido.

:::


## Pacote TidierData.jl

```{julia}
#| echo: true

using TidierData

@chain dados begin
    @filter(popularity > 50)
    @arrange(desc("energy"))
    @select(track_name, popularity, energy, acousticness)
    @slice(1:5)
end
```


## Pacote TidierData.jl

Para quem já está familiarizado com a linguagem `R`, a função `@chain()` é similar ao pipeline `%>%` ou `|>`, usado para encadear várias operações em sequência no mesmo conjunto de dados.

- `@filter()` : Filtra as linhas com base em uma restrição;
- `@arrange()` : Ordena as linhas com base em uma coluna (`desc()` para definir ordem crescente ou decrescente);
- `@select()` : Seleciona as colunas de interesse;
- `@slice()` : Seleciona as linhas para visualização.

. . . 

> Obs.: A função `desc()` é uma função auxiliar.


## Pacote TidierData.jl


Existem algumas funções auxiliares do pacote que é importante citarmos:

- `across()` : Aplica uma função a várias colunas de uma vez;
- `n()` e `row_number()` : Retornam o número total de linhas ou o número da linha;
- `replace_missing()` : Substitui valores ausentes em uma coluna por um valor especificado.


## Pacote TidierData.jl

Outras funções auxiliares de outros pacotes que vale mencionar:

- `dropmissing()` : Remove as linhas que contêm valores faltantes (*missing*);
- `unique()` : Retorna os valores distintos únicos de um vetor ou coluna, removendo duplicatas;
- `nrow()` : Retorna o número de linhas de um DataFrame ou matriz;
- `any()` : Testa se **pelo menos um** elemento de uma coleção (ou resultado de uma condição) é verdadeiro; retorna `true` ou `false`.


. . . 


::: {.callout-note icon=false}
### Dica

Use a função `any()` e a função `ismissing` no formato `row -> any(ismissing, row)` para verificar se há colunas sem informação. Nesse caso, a função `filter()` da base do `Julia` é mais eficiente, no formato `filter(condição, dados)`.
:::


## Pacote TidierData.jl


Limpeza do dataset do Spotify: Tratando valores faltantes

. . . 


```{julia}
#| echo: true
faltantes = filter(row -> any(ismissing, row), dados)
```


. . . 

```{julia}
#| echo: true
@chain faltantes begin
    @slice(1)
end
```


## Pacote TidierData.jl


Vamos remover as linhas que possuem valores faltantes.

```{julia}
#| echo: true
dados = @chain dados begin
    dropmissing()
end
```


## Pacote TidierData.jl

Verificaremos possíveis faixas duplicadas, e retirá-las caso haja alguma.

```{julia}
#| echo: true

nrow(unique(dados, :track_id)), nrow(dados)
dados = unique(dados, :track_id)
```



# Análise Exploratória de Dados (EDA)

## EDA

-   `Julia` torna possível compreender e explorar conjuntos de dados, identificando padrões, tendências e possíveis outliers antes da modelagem.
-   Nesse tópico, iremos explorar algumas estatísticas resumo (média, mediana, desvio-padrão, etc.) e algumas distribuições (discretas e contínuas).
-   Os pacotes `Statistics.jl`, `StatsBase.jl`, `DataFrames.jl` e `TidierData.jl` serão essenciais para a análise `r emo::ji("cool")`.

. . . 

```{julia}
#| echo: true
using DataFrames
using StatsBase
using Statistics
using TidierData
```


## EDA: Medidas de tendência central

Algumas das principais medidas são:

-   `mean(x)` representa média aritmética
-   `median(x)` representa a mediana
-   `mode(x)` representa a moda (pacote `StatsBase.jl`)


. . . 

**Ex.:**

```{julia}
#| echo: true
x = [1, 2, 2, 2, 5, 6, 7];
mean(x)
```



## EDA: Medidas de dispersão

-   `var(x)` representa variância
-   `std(x)` representa o desvio padrão
-   `minimum(x)` e `maximum(x)` são os valores mínimo e máximo
-   `quantile(x, p)` repesenta quantis (`p` é o parâmetro da posição relativa da distribuição)


. . . 

**Ex.:**


```{julia}
#| echo: true
std(x)
```


## EDA: Contagem e frequência

-   `length(x)` é o número de elementos
-   `count(cond, x)` conta elementos que satisfazem uma condição `cond`
-   `countmap(x)` cria uma tabela de frequências (pacote `StatsBase.jl`)

. . . 


```{julia}
#| echo: true
x = ["maçã", "banana", "maçã", "laranja", "banana", "maçã"];
countmap(x)
```



## EDA: Informações resumidas

-   `describe(df)` fornece estatísticas descritivas de um data frame
-   `cor(x, y)` descreve uma matriz de correlação entre duas variáveis `x` e `y`
-   `cov(x, y)` covariância das variáveis `x` e `y`

. . . 

```{julia}
#| echo: true
df = DataFrame(
    idade = [20, 25, 30, 35, 40],
    altura = [1.70, 1.75, 1.80, 1.65, 1.90],
    nome = ["Ana", "Bruno", "Carlos", "Daniela", "Eduardo"]
);
describe(df)
```



## EDA


::: {.callout-note icon=false}
### Dica
Para identificar os cinco artistas com maior número de faixas no dataset, utilize as funções `groupby()` e `combine()` para criar uma nova tabela contendo duas colunas: uma com o nome dos artistas e outra com a contagem de faixas. Em seguida, use `sort!()` para ordenar de forma decrescente e `first()` para exibir apenas os primeiros registros.
:::


. . . 



``` julia
using Statistics, StatsPlots, Plots

artists = combine(groupby(df, :artists), nrow => :n_tracks)
sort!(artists, :n_tracks, rev=true)
first(artists, 5)  # Top 5 artistas
```

## EDA: Análise descritiva do dataset


::: {.callout-note icon=false}
### Dica
Para filtrar as faixas de um artista específico, como George Jones, utilize `filter()` em conjunto com `occursin()` na coluna :artists. Depois, aplique a função `describe()` às variáveis numéricas para obter as estatísticas descritivas, como média, mediana, mínimo e máximo.
:::


. . . 



``` {julia}
#| echo: true
using Statistics, StatsPlots, Plots

df_george = filter(:artists => x -> occursin("George Jones", x), df)

vars_numericas = [:popularity, :duration_ms, :danceability, :energy,
                  :loudness, :speechiness, :acousticness, :instrumentalness,
                  :liveness, :valence, :tempo]
                  
describe(select(df_george, vars_numericas))
```

## EDA:Visualização de dados

-   O Julia oferece diversas bibliotecas para criar visualizações estatísticas de forma simples e flexível, permitindo a análise e interpretação de dados de maneira visual. Algumas bibliotecas populares incluem `Plots.jl`, `StatsPlots.jl`, `Makie.jl` e `Gadfly.jl`.

    ``` julia
    import Pkg

    Pkg.add("Plots")
    Pkg.add("StatsPlots")
    Pkg.add("Makie")
    Pkg.add("Gadfly")
    Pkg.add("Distributions")
    ```

    ``` julia
    using Plots, StatsPlots, Makie, Gadfly, Distributions
    ```

## EDA: Boxplot

-   `bloxplot(x)` resume a distribuição dos dados destacando mediana, quartis e possíveis outliers.

**Ex.:**

``` {julia}
#| echo: true
x = [5.1, 5.5, 5.3, 5.0, 5.2, 5.8, 5.4, 6.0, 4.9, 5.6, 5.7, 6.2]

boxplot(x;
    xlabel = "Amostra",
    ylabel = "Valores",
    title = "Boxplot de Exemplo",
    legend = false
)
```

## Barplot (gráfico de barras)

-   `bar(x)` representa frequências ou valores médios para categorias.

**Ex.:**

``` {julia}
#| echo: true
generos = ["Pop", "Rock", "Jazz", "Funk"]
freqs = [50, 30, 15, 5]

bar(generos, freqs, xlabel="Gênero", ylabel="Frequência", 
    title="Número de músicas por gênero", legend=false)
```

## EDA: Histograma

-   `histogram(x)` exibe a distribuição de frequências de variáveis contínuas. Caso você não possua um conjunto de dados real, é possível gerar números pseudoaleatórios com o pacote `Random.jl` e criar uma distribuição normal utilizando o pacote `Distributions.jl`.

**Ex.:**

``` {julia}
#| echo: true
using Random, Distributions, Plots

alturas = rand(Normal(170, 7), 500) # median = 7; std = 7; amostra = 500

histogram(
    alturas,
    bins = 20,
    xlabel = "Altura (cm)",
    ylabel = "Frequência",
    title = "Distribuição das Alturas",
    legend = false
)
```

## EDA: Curva de densidade

-   Para gerar a curva de densidade em `Julia`, você pode usar o argumento `normalize=:pdf` dentro da função `histogram()`:

**Ex.:**

``` {julia}
using Random, Distributions, Plots

alturas = rand(Normal(170, 7), 500) # median = 7; std = 7; amostra = 500

histogram(alturas, bins=20, normalize=:pdf, alpha=0.4, label="Histograma")
plot!(density(alturas), label="Curva de densidade", lw=2, color=:blue)
```

## EDA: Gráfico de dispersão

-   `scatter(x)` mostra a relação entre duas variáveis numéricas.

**Ex.:**

``` {julia}
#| echo: true
using Random, Plots

Random.seed!(123)

x = 1:20
y = x .+ randn(20) .* 2

scatter(x, y,
    xlabel = "Variável X",
    ylabel = "Variável Y",
    title = "Exemplo de Gráfico de Dispersão",
    legend = false,
    color = :blue,
    markerstrokecolor = :black)
```

## EDA: Matrizes de correlacão e mapas de calor

-   Matriz de Correlação: Tabela que mostra o grau de correlação (associação linear) entre pares de variáveis numéricas.
-   Mapa de Calor (Heatmap): Representação visual de uma matriz, onde os valores numéricos são exibidos como cores.

**Por que usar?**

-   Identificar relações fortes ou fracas entre variáveis.
-   Detectar multicolinearidade em análise estatística e modelagem.
-   Facilitar a interpretação visual de grandes conjuntos de dados


## EDA: Matrizes de correlacão e mapas de calor


**Ex.:**

``` {julia}
#| echo: true
using Random, StatsPlots

Random.seed!(123)

n = 50
A = randn(n) .* 10
B = A .* 0.5 .+ randn(n) .* 5
C = randn(n) .* 2
D = 0.8 .* A .- 0.3 .* C .+ randn(n)

df_rand = DataFrame(A=A, B=B, C=C, D=D)

corr_mat = cor(Matrix(df_rand))

heatmap(names(df_rand), names(df_rand), corr_mat;
    c = :coolwarm, clim=(-1,1), aspect_ratio=1,
    title="Matriz de Correlação (Dados Aleatórios)",
    xlabel="", ylabel="", xrotation=45, yrotation=45)
```

## EDA: Gerando gráficos do dataset

-   Para o exercício 5, utilizamos a função `histogram()` aplicada à nova variável `duration_min`. Em seguida, normalizamos os valores para que a área total do histograma seja igual a 1, permitindo sobrepor e comparar com a curva de densidade.

``` {julia}
#| echo: true
using Statistics, StatsPlots, Plots

df.duration_min = df.duration_ms ./ 60000

histogram(df[!, :duration_min],
    bins = 50,
    xlabel = "Duração (min)",
    ylabel = "Número de músicas",
    title = "Distribuição da duração das músicas",
    normalize = true,
    legend = false)
    
density!(df[!, :duration_min], linewidth = 2, label = "Densidade")
```

## EDA: Gerando gráficos do dataset

-   O gráfico de heatmap foi construído a partir da matriz, utilizando rótulos correspondentes aos nomes das variáveis e aplicando um esquema de cores `(c = :coolwarm)` para destacar relações positivas e negativas. Além disso, a escala foi definida no intervalo \[-1, 1\] e os nomes dos eixos foram rotacionados para facilitar a leitura.

``` {julia}
using Statistics, StatsPlots, Plots

var_numericas = [:popularity, :duration_ms, :danceability, :energy,
             :loudness, :speechiness, :acousticness, :instrumentalness,
             :liveness, :valence, :tempo]

# Selecionar e limpar
numdf = select(df, variables)

# Matriz de correlação
corr_matrix = cor(Matrix(numdf))

# Heatmap
heatmap(String.(var_numericas), String.(var_numericas), corr_matrix;
    c = :coolwarm, clim = (-1, 1), aspect_ratio = 1,
    xlabel = "", ylabel = "", title = "Matriz de correlação",
    xrotation = 45,
    yrotation = 45)
```

# Modelar

## Regressão e Classificação

## Referências

-   [Vituri, G. & and Scheuch, C. (2025). Tidier Data Science with Julia.](https://tidierorg.github.io/TidierBook/)
-   [Silva, H. A. V. & da Silva, A. D. M. (2025). Do Zero ao Julia: Introdução ao pacote TidierData.jl. Retrieved from https://ime.unicamp.br/julialang/Blog/tidierdata.html](https://ime.unicamp.br/julialang/Blog/tidierdata.html)
