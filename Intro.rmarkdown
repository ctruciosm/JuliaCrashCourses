---
title: "Julia para Ciência de Dados"
subtitle: "Um guia introdutório para importar, transformar, analisar e modelar dados"
lang: "pt"
author: "**Professor: Carlos Trucíos (DE)** <br> **Instrutores:** Arthur da Silva (DMA), Henrique Velloso (DE) e Sarah Pereira (DMA)."
institute: "7ª  Semana da Matemática Aplicada (SEMAP), <br> Universidade Estadual de Campinas (UNICAMP) <br> Agosto de 2025"
knitr:
    opts_chunk: 
      fig.align: 'center'
execute:
    message: false
    warning: false
format:
    revealjs:
        slide-number: true
        toc: true
        toc-depth: 1
        toc-title: Agenda
        self-contained: false
        chalkboard: true
        width: 1600
        height: 900
        theme: [default, styles.scss]
        incremental: true
        code-fold: false
        logo: "imagens/imecc.png"
        footer: "7ª SEMAP    |   Agosto de 2025    |    [www.ime.unicamp.br/julialang](https://ime.unicamp.br/julialang)"
        highlight-style: "a11y"
        title-slide-attributes:
            data-background-image: "imagens/unicamp.png"
            data-background-size: 20%
            data-background-position: 99% 5%
            data-background-opacity: "1"
editor: source
#  markdown: 
#    wrap: 72
---




# Por que Julia?

## Por que escolher Julia?

-   A linguagem de programação `Julia`, lançada oficialmente em 2012, tem se destacado como uma alternativa moderna para ciência de dados e computação científica, competindo com linguagens como `Matlab`, `Python` e `R`;
-   É utilizada não apenas na academia, [mas também fora dela.](https://ime.unicamp.br/julialang/Blog/Julia%20no%20Mercado%20de%20Trabalho.html);
-   `Julia` é gratuita;
-   `Julia` oferece desempenho próximo ao de C++, aliado à facilidade de aprendizado e sintaxe simples, comparáveis a `Python` e `R`;
-   `Julia` permite escrever código com símbolos matemáticos diretamente `r emo::ji("nerd")`, facilitando a expressão de conceitos científicos;
-   `Julia` resolve o problema das duas linguagens `r emo::ji("cool")`;
-   Etc.

## Do Zero ao Julia

<center>

![Website Do Zero ao Julia: www.ime.unicamp.br/julialang](imagens/DoZeroaoJulia.png){width="1000px"}

</center>

# Importação de dados

Nesta seção veremos como importar nossos datasets, estando eles armazenados localmente ou online. Também veremos a diferença na leitura de diferentes formatos, como **.csv**, **.txt** e **.xlsx**.

## Pacotes necessários

O `Julia` conta com diversos pacotes que usamos para leitura de datasets, dentre eles vamos focar nos seguintes:

``` julia
import Pkg

Pkg.add("DataFrames");
Pkg.add("CSV")
Pkg.add("XLSX")
```

-   `DataFrames` : Manipulação e análise de dados em formato tabular, similar ao pandas (`Python`) ou data.frame (`R`);
-   `CSV` : Leitura e escrita de arquivos CSV de forma rápida e eficiente;
-   `XLSX` : Leitura e escrita de arquivos Excel (.xlsx).

## Funções básicas

Com os pacotes necessários instalados, agora vejamos como as funções de leitura funcionam:

``` julia
using DataFrames, CSV, XLSX

# .csv

df_csv = CSV.read("caminho/dados.csv", DataFrame)

# .txt

df_txt = CSV.read("caminho/dados.txt", DataFrame, delim=';')

# .xlsx

sheets = XLSX.readxlsx("caminho/dados.xlsx")
df_xlsx = DataFrame(sheets)
```

## Funções básicas

Podemos usar a função `download()` é usada para baixar um arquivo temporariamente e retorna o caminho local onde ele foi salvo.

**Ex.:**

``` julia
dados_csv = CSV.read(download(url), DataFrame, delim=';')

first(dados_csv, 5) # Podemos usar a função first() para visualizar as primeiras linhas do dataset
```

## Leitura da base de dados

Agora, vamos ler os dados que usaremos na aula de hoje.



```{julia}
#| echo: false

begin
    import Pkg
    redirect_stdout(devnull) do
        redirect_stderr(devnull) do
            Pkg.add("TidierData")
            Pkg.add("PrettyTables")
        end
    end
end
```

```{julia}
#| echo: fenced

begin
    import Pkg
    redirect_stdout(devnull) do
        redirect_stderr(devnull) do
            Pkg.add("DataFrames")
            Pkg.add("CSV")
            Pkg.add("XLSX")
        end
    end
end
```

```{julia}
#| echo: fenced
#| output: false

using DataFrames, CSV

file = "https://raw.githubusercontent.com/Arthur-Dionizio/minicurso-julia/main/datasets/dataset.csv"

dados = CSV.read(download(file), DataFrame)
```



## Leitura da base de dados



```{julia}
#| echo: fenced
#| output: true
#| eval: true

using DataFrames, TidierData

@chain dados begin
    @slice(1:6)
end
```



# Banco de dados

## Dados de faixas do Spotify

Vamos analisar um banco de dados de faixas do Spotify abrangendo 125 gêneros diferentes. Aqui estão as principais colunas do dataset:

1.  **track_name**: Nome da faixa;

2.  **artists**: Os nomes dos artistas que interpretaram a faixa. Se houver mais de um artista, eles serão separados por ';' ;

3.  **album_name**: O nome do álbum de onde a faixa pertence;

4.  **popularity**: A popularidade de uma faixa é um valor entre 0 e 100, sendo 100 o mais popular, sendo calculada a partir (de forma geral) do número de streams daquela faixa, e o quão recente foram essas streams;

5.  **duration_ms**: A duração da faixa em milissegundos;

6.  **danceability**: A dançabilidade descreve o quão adequada uma faixa é para dançar com base em uma combinação de elementos musicais, incluindo andamento, estabilidade do ritmo, força da batida e regularidade geral. Um valor de 0,0 é o menos dançante e 1,0 o mais dançante;

## Dados de faixas do Spotify

7.  **energy**: Energia é uma medida de 0,0 a 1,0 e representa uma medida perceptual de intensidade e atividade. Normalmente, músicas energéticas parecem rápidas, altas e barulhentas. Por exemplo, o death metal tem alta energia, enquanto um prelúdio de Bach tem baixa pontuação na escala;

8.  **loudness**: O volume total de uma faixa em decibéis (dB);

9.  **speechiness**: Detecta a presença de palavras faladas em uma faixa. Quanto mais exclusivamente semelhante à fala for a gravação (por exemplo, talk show, audiolivro, poesia), mais próximo de 1,0 será o valor do atributo. Valores acima de 0,66 descrevem faixas que provavelmente são compostas inteiramente de palavras faladas. Valores entre 0,33 e 0,66 descrevem faixas que podem conter música e fala, seja em seções ou em camadas, incluindo casos como rap. Valores abaixo de 0,33 provavelmente representam música e outras faixas que não se assemelham à fala.

10. **acousticness**: Uma medida de confiança de 0,0 a 1,0 para determinar se a faixa é acústica. 1,0 representa alta confiança de que a faixa é acústica.

## Dados de faixas do Spotify

11. **valence**: Uma medida de 0,0 a 1,0 que descreve a positividade musical transmitida por uma faixa. Faixas com alta valência soam mais positivas (por exemplo, felizes, alegres, eufóricas), enquanto faixas com baixa valência soam mais negativas (por exemplo, tristes, deprimidas, raivosas);

12. **tempo**: O andamento estimado geral de uma faixa em batidas por minuto (BPM);

13. **track_genre**: O gênero da faixa;

14. **instrumentalness**: Prevê se uma faixa não contém vocais. Sons de "Ooh" e "aah" são tratados como instrumentais neste contexto. Faixas de rap ou palavra falada são claramente "vocais". Quanto mais próximo o valor de instrumentalidade estiver de 1,0, maior a probabilidade de a faixa não conter conteúdo vocal.

15. **liveness**: Detecta a presença de público na gravação. Valores mais altos de ao vivo representam uma probabilidade maior de que a faixa tenha sido tocada ao vivo. Um valor acima de 0,8 fornece alta probabilidade de que a faixa seja ao vivo.

# Manipulação de banco de dados

Agora que temos o nosso dataset, vamos passar por algumas funções e pacotes que vão nos auxiliar na limpeza dos nossos dados!

## Tidier.jl

A biblioteca `Tidier.jl` possui vários pacotes que auxiliam na manipulação e análise de datasets. Para quem está vindo do `R`, esses pacotes são bem similares e intuitivos. Aqui estão alguns dos pacotes:

-   `TidierData` : Implementação 100% `Julia` dos pacotes `dplyr` e `tidyr` do `R`. Usado na tranformação e manipulação dos dados;
-   `TidierPlots` : Implementação 100% `Julia` do pacote `ggplot2` do `R`;
-   `TidierStrings` : O objetivo deste pacote é replicar o `stringr` do `R` em `Julia` de uma forma que funcione com o Tidier ou como uma função autônoma.

> Acessem o link `https://tidierorg.github.io/Tidier.jl/v1.6.1/` para mais informações!

## Pacote TidierData.jl

Para a nossa análise de hoje, vamos utilizar principalmente o pacote `TidierData`.

### Funções Macro

Para suportar a programação no estilo `R`, o `TidierData.jl` é implementado usando **macros**. Isso ocorre porque as **macros** são capazes de "capturar" o código antes de executá-lo, o que permite que o pacote suporte "expressões *tidy*" semelhantes ao `R` que, de outra forma, não seriam consideradas código `Julia` válido.



```{julia}
#| echo: fenced

using TidierData

@chain dados begin
    @filter(popularity > 50)
    @arrange(desc("energy"))
    @select(track_name, popularity, energy, acousticness)
    @slice(1:5)
end
```



## Pacote TidierData.jl

-   Para quem já está familiarizado com a linguagem `R`, a função `@chain()` é similar ao pipeline `%>%` ou `|>`, usado para encadear várias operações em sequência no mesmo conjunto de dados.

    -   `@filter()` : Filtra as linhas com base em uma restrição;
    -   `@arrange()` : Ordena as linhas com base em uma coluna (`desc()` para definir ordem crescente ou decrescente);
    -   `@select()` : Seleciona as colunas de interesse;
    -   `@slice()` : Seleciona as linhas para visualização.

> Obs.: A função `desc()` é uma função auxiliar.

------------------------------------------------------------------------

### Funções auxiliares

Algumas funções auxiliares do pacote que é importante citarmos:

-   `across()` : Aplica uma função a várias colunas de uma vez;
-   `n()` e `row_number()` : Retornam o número total de linhas ou o número da linha;
-   `replace_missing()` : Substitui valores ausentes em uma coluna por um valor especificado.

Outras funções auxiliares de outros pacotes que vale mencionar:

-   `dropmissing()` : Remove as linhas que contêm valores faltantes (*missing*);
-   `unique()` : Retorna os valores distintos únicos de um vetor ou coluna, removendo duplicatas;
-   `nrow()` : Retorna o número de linhas de um DataFrame ou matriz;
-   `any()` : Testa se **pelo menos um** elemento de uma coleção (ou resultado de uma condição) é verdadeiro; retorna `true` ou `false`.

## Limpeza do dataset do Spotify

### Tratando valores faltantes

> Dica: Use a função `any()` e a função `ismissing` no formato `row -> any(ismissing, row)` para verificar se há colunas sem informação. Nesse caso, a função `filter()` da base do `Julia` é mais eficiente, no formato `filter(condição, dados)`.



```{julia}
#| echo: fenced
#| output: false

using DataFrames, TidierData

faltantes = filter(row -> any(ismissing, row), dados)
```

```{julia}
#| echo: fenced
#| output: true

using TidierData

@chain faltantes begin
    @slice(1)
end
```



------------------------------------------------------------------------

### Tratando valores faltantes

Vamos remover as linhas que possuem valores faltantes.



```{julia}
#| echo: fenced
#| output: false

using TidierData, DataFrames

dados = @chain dados begin
    dropmissing()
end
```



## Tratando valores duplicados

Verificaremos possíveis faixas duplicadas, e retirá-las caso haja alguma.



```{julia}
#| echo: fenced
#| output: true

using DataFrames, PrettyTables

nrow(unique(dados, :track_id)), nrow(dados)

dados = unique(dados, :track_id)
```



# Análise Exploratória de Dados (EDA)

## EDA

-   `Julia` torna possível compreender e explorar conjuntos de dados, identificando padrões, tendências e possíveis outliers antes da modelagem.

-   Nesse tópico, iremos explorar as principais métricas estatísticas (média, mediana, desvio-padrão, etc.) e algumas distribuições discretas e contínuas.

-   Os pacotes `Statistics.jl`, `StatsBase.jl`, `DataFrames.jl` e `TidierData.jl` serão essenciais para a análise `r emo::ji("cool")`.

    ``` julia
    import Pkg

    Pkg.add("StatsBase")
    Pkg.add("DataFrames")
    Pkg.add("TidierData")
    ```

    ``` julia
    using Statistics, StatsBase, DataFrames, TidierData
    ```

## Medidas de tendência central

`Julia` tem como uma vantagem uma sintaxe muito similar a Python e R, o que torna seu processo de aprendizado muito mais rápido e eficiente! Algumas das principais medidas são:

-   `mean(x)` representa média aritmética
-   `median(x)` representa a mediana
-   `mode(x)` representa a moda (pacote `StatsBase.jl`)

**Ex.:**

``` julia
x = [1, 2, 2, 2, 5, 6, 7]

mean(x)
```

Saída:

``` julia
3.5714285714285716
```

## Medidas de dispersão

-   `var(x)` representa variância
-   `std(x)` representa o desvio padrão
-   `minimum(x)` e `maximum(x)` são os valores mínimo e máximo
-   `quantile(x, p)` repesenta quantis (`p` é o parâmetro da posição relativa da distribuição)

**Ex.:**

``` julia
A = [1 2 3;
     4 5 6;
     7 8 9]

std(x)
```

Saída:

``` julia
2.7386127875258306
```

## Contagem e frequência

-   `length(x)` é o número de elementos
-   `count(cond, x)` conta elementos que satisfazem uma condição `cond`
-   `countmap(x)` cria uma tabela de frequências (pacote `StatsBase.jl`)

**Ex.:**

``` julia
x = ["maçã", "banana", "maçã", "laranja", "banana", "maçã"]

std(x)
```

Saída:

``` julia
Dict{String, Int64} with 3 entries:
  "laranja" => 1
  "banana"  => 2
  "maçã"    => 3
```

## Informações resumidas

-   `describe(df)` fornece estatísticas descritivas de um data frame
-   `cor(x, y)` descreve uma matriz de correlação entre duas variáveis `x` e `y`
-   `cov(x, y)` covariância das variáveis `x` e `y`

``` julia
df = DataFrame(
    idade = [20, 25, 30, 35, 40],
    altura = [1.70, 1.75, 1.80, 1.65, 1.90],
    nome = ["Ana", "Bruno", "Carlos", "Daniela", "Eduardo"]
)

describe(df)
```

Saída:

``` julia
3×7 DataFrame
 Row │ variable  mean     min     median  max     nmissing  eltype
     │ Symbol    Float64  Real    Float64 Real    Int64     DataType
─────┼──────────────────────────────────────────────────────────────
   1 │ idade       30.0     20       30.0     40         0  Int64
   2 │ altura       1.76     1.65     1.75     1.9        0  Float64
   3 │ nome         NaN      Ana      NaN      Eduardo    0  String
```

## Análise descritiva do dataset

> Dica: Para identificar os cinco artistas com maior número de faixas no dataset, utilize as funções `groupby()` e `combine()` para criar uma nova tabela contendo duas colunas: uma com o nome dos artistas e outra com a contagem de faixas. Em seguida, use `sort!()` para ordenar de forma decrescente e `first()` para exibir apenas os primeiros registros.

``` julia
using Statistics, StatsPlots, Plots

artists = combine(groupby(df, :artists), nrow => :n_tracks)
sort!(artists, :n_tracks, rev=true)
first(artists, 5)  # Top 5 artistas
```

## Análise descritiva do dataset

> Dica: Para filtrar as faixas de um artista específico, como George Jones, utilize `filter()` em conjunto com `occursin()` na coluna :artists. Depois, aplique a função `describe()` às variáveis numéricas para obter as estatísticas descritivas, como média, mediana, mínimo e máximo.

``` julia
using Statistics, StatsPlots, Plots

df_george = filter(:artists => x -> occursin("George Jones", x), df)

vars_numericas = [:popularity, :duration_ms, :danceability, :energy,
                  :loudness, :speechiness, :acousticness, :instrumentalness,
                  :liveness, :valence, :tempo]
                  
describe(select(df_george, vars_numericas))
```

## Visualizações estatísticas

-   O Julia oferece diversas bibliotecas para criar visualizações estatísticas de forma simples e flexível, permitindo a análise e interpretação de dados de maneira visual. Algumas bibliotecas populares incluem `Plots.jl`, `StatsPlots.jl`, `Makie.jl` e `Gadfly.jl`.

    ``` julia
    import Pkg

    Pkg.add("Plots")
    Pkg.add("StatsPlots")
    Pkg.add("Makie")
    Pkg.add("Gadfly")
    Pkg.add("Distributions")
    ```

    ``` julia
    using Plots, StatsPlots, Makie, Gadfly, Distributions
    ```

## Boxplot

-   `bloxplot(x)` resume a distribuição dos dados destacando mediana, quartis e possíveis outliers.

**Ex.:**

``` julia
x = [5.1, 5.5, 5.3, 5.0, 5.2, 5.8, 5.4, 6.0, 4.9, 5.6, 5.7, 6.2]

boxplot(x;
    xlabel = "Amostra",
    ylabel = "Valores",
    title = "Boxplot de Exemplo",
    legend = false
)
```

## Saída:

![](images/boxplot.png){fig-align="center"}

## Barplot (gráfico de barras)

-   `bar(x)` representa frequências ou valores médios para categorias.

**Ex.:**

``` julia
generos = ["Pop", "Rock", "Jazz", "Funk"]
freqs = [50, 30, 15, 5]

bar(generos, freqs, xlabel="Gênero", ylabel="Frequência", 
    title="Número de músicas por gênero", legend=false)
```

## Saída:

![](images/bar.png){fig-align="center"}

## Histograma

-   `histogram(x)` exibe a distribuição de frequências de variáveis contínuas. Caso você não possua um conjunto de dados real, é possível gerar números pseudoaleatórios com o pacote `Random.jl` e criar uma distribuição normal utilizando o pacote `Distributions.jl`.

**Ex.:**

``` julia
using Random, Distributions, Plots

alturas = rand(Normal(170, 7), 500) # median = 7; std = 7; amostra = 500

histogram(
    alturas,
    bins = 20,
    xlabel = "Altura (cm)",
    ylabel = "Frequência",
    title = "Distribuição das Alturas",
    legend = false
)
```

## Saída:

![](images/hist.png){fig-align="center"}

## Curva de densidade

-   Para gerar a curva de densidade em `Julia`, você pode usar o argumento `normalize=:pdf` dentro da função `histogram()`:

**Ex.:**

``` julia
using Random, Distributions, Plots

alturas = rand(Normal(170, 7), 500) # median = 7; std = 7; amostra = 500

histogram(alturas, bins=20, normalize=:pdf, alpha=0.4, label="Histograma")
plot!(density(alturas), label="Curva de densidade", lw=2, color=:blue)
```

## Saída:

![](images/dens.png){fig-align="center"}

## Gráfico de dispersão

-   `scatter(x)` mostra a relação entre duas variáveis numéricas.

**Ex.:**

``` julia
using Random, Plots

Random.seed!(123)

x = 1:20
y = x .+ randn(20) .* 2

scatter(x, y,
    xlabel = "Variável X",
    ylabel = "Variável Y",
    title = "Exemplo de Gráfico de Dispersão",
    legend = false,
    color = :blue,
    markerstrokecolor = :black)
```

## Saída:

![](images/disp.png){fig-align="center"}

## Matrizes de correlacão e mapas de calor

-   Matriz de Correlação: Tabela que mostra o grau de correlação (associação linear) entre pares de variáveis numéricas.
-   Mapa de Calor (Heatmap): Representação visual de uma matriz, onde os valores numéricos são exibidos como cores.

**Por que usar?**

-   Identificar relações fortes ou fracas entre variáveis.
-   Detectar multicolinearidade em análise estatística e modelagem.
-   Facilitar a interpretação visual de grandes conjuntos de dados

**Ex.:**

``` julia
using Random, StatsPlots

Random.seed!(123)

n = 50
A = randn(n) .* 10
B = A .* 0.5 .+ randn(n) .* 5
C = randn(n) .* 2
D = 0.8 .* A .- 0.3 .* C .+ randn(n)

df_rand = DataFrame(A=A, B=B, C=C, D=D)

corr_mat = cor(Matrix(df_rand))

heatmap(names(df_rand), names(df_rand), corr_mat;
    c = :coolwarm, clim=(-1,1), aspect_ratio=1,
    title="Matriz de Correlação (Dados Aleatórios)",
    xlabel="", ylabel="", xrotation=45, yrotation=45)
```

## Saída:

![](images/heatmap.png){fig-align="center"}

## Gerando gráficos do dataset

-   Para o exercício 5, utilizamos a função `histogram()` aplicada à nova variável `duration_min`. Em seguida, normalizamos os valores para que a área total do histograma seja igual a 1, permitindo sobrepor e comparar com a curva de densidade.

``` julia
using Statistics, StatsPlots, Plots

df.duration_min = df.duration_ms ./ 60000

histogram(df[!, :duration_min],
    bins = 50,
    xlabel = "Duração (min)",
    ylabel = "Número de músicas",
    title = "Distribuição da duração das músicas",
    normalize = true,
    legend = false)
    
density!(df[!, :duration_min], linewidth = 2, label = "Densidade")
```

## Saída:

![](images/ex5.png){fig-align="center"}

## Gerando gráficos do dataset

-   O gráfico de heatmap foi construído a partir da matriz, utilizando rótulos correspondentes aos nomes das variáveis e aplicando um esquema de cores `(c = :coolwarm)` para destacar relações positivas e negativas. Além disso, a escala foi definida no intervalo \[-1, 1\] e os nomes dos eixos foram rotacionados para facilitar a leitura.

``` julia
using Statistics, StatsPlots, Plots

var_numericas = [:popularity, :duration_ms, :danceability, :energy,
             :loudness, :speechiness, :acousticness, :instrumentalness,
             :liveness, :valence, :tempo]

# Selecionar e limpar
numdf = select(df, variables)

# Matriz de correlação
corr_matrix = cor(Matrix(numdf))

# Heatmap
heatmap(String.(var_numericas), String.(var_numericas), corr_matrix;
    c = :coolwarm, clim = (-1, 1), aspect_ratio = 1,
    xlabel = "", ylabel = "", title = "Matriz de correlação",
    xrotation = 45,
    yrotation = 45)
```

## Saída:

![](images/ex6.png)

# Modelar

## Regressão e Classificação

## Referências

-   [Vituri, G. & and Scheuch, C. (2025). Tidier Data Science with Julia.](https://tidierorg.github.io/TidierBook/)
-   [Silva, H. A. V. & da Silva, A. D. M. (2025). Do Zero ao Julia: Introdução ao pacote TidierData.jl. Retrieved from https://ime.unicamp.br/julialang/Blog/tidierdata.html](https://ime.unicamp.br/julialang/Blog/tidierdata.html)

